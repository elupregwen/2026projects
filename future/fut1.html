<!DOCTYPE html>
<html>
<head>
    <title>üéÜ Hand Gesture - VISUAL EFFECTS EDITION</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: #000;
            color: white;
            overflow-x: hidden;
            position: relative;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 10;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(90deg, rgba(0,255,136,0.1), rgba(0,255,255,0.1));
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0,255,136,0.3);
        }
        
        h1 {
            font-size: 2.5em;
            background: linear-gradient(45deg, #00ff88, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }
        
        .main-area {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .camera-section {
            flex: 1;
            min-width: 300px;
        }
        
        .camera-box {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            padding: 15px;
            border: 2px solid #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
            margin-bottom: 20px;
        }
        
        .camera-box h2 {
            margin-bottom: 10px;
            color: #00ff88;
        }
        
        video, canvas {
            width: 100%;
            height: 300px;
            border-radius: 10px;
            background: #111;
            display: block;
        }
        
        .gesture-display {
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid #00ffff;
            margin-top: 20px;
        }
        
        #gestureText {
            font-size: 3em;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .effects-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            overflow: hidden;
        }
        
        /* Particle effects */
        .particle {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
        }
        
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            opacity: 0.8;
        }
        
        .laser {
            position: absolute;
            height: 3px;
            background: linear-gradient(90deg, #ff0000, #ffff00);
            transform-origin: 0 0;
        }
        
        .ripple {
            position: absolute;
            border: 2px solid #00ffff;
            border-radius: 50%;
            animation: ripple 1s ease-out;
        }
        
        @keyframes ripple {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(5); opacity: 0; }
        }
        
        .firework {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 20px;
        }
        
        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 10px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.5em;
            color: #00ff88;
            font-weight: bold;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }
        
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(45deg, #00ff88, #00cc6a);
            color: black;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1em;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 136, 0.4);
        }
        
        button#toggleEffects {
            background: linear-gradient(45deg, #ff00ff, #cc00cc);
        }
        
        .tutorial {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            margin-top: 30px;
        }
        
        .gesture-examples {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }
        
        .example {
            background: rgba(0, 255, 136, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            width: 150px;
        }
        
        .example-icon {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .fps-display {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 10px;
            border: 1px solid #00ff88;
            font-family: monospace;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="fps-display">
        FPS: <span id="fps">0</span>
    </div>
    
    <!-- Effects will be added here -->
    <div class="effects-overlay" id="effectsOverlay"></div>
    
    <div class="container">
        <header>
            <h1>‚ú® MAGIC HAND GESTURES ‚ú®</h1>
            <p>Wave your hand to create amazing visual effects!</p>
        </header>
        
        <div class="main-area">
            <div class="camera-section">
                <div class="camera-box">
                    <h2>üì∏ Live Camera</h2>
                    <video id="videoInput" autoplay playsinline muted></video>
                </div>
                
                <div class="camera-box">
                    <h2>üñêÔ∏è Hand Tracking</h2>
                    <canvas id="canvasOutput" width="640" height="480"></canvas>
                </div>
            </div>
            
            <div class="gesture-display">
                <h2>üéØ Current Gesture</h2>
                <div id="gestureText">üëã Waiting for hand...</div>
                
                <div class="stats">
                    <div class="stat-item">
                        <div>Hands</div>
                        <div class="stat-value" id="handCount">0</div>
                    </div>
                    <div class="stat-item">
                        <div>Confidence</div>
                        <div class="stat-value" id="confidence">0%</div>
                    </div>
                    <div class="stat-item">
                        <div>Effects</div>
                        <div class="stat-value" id="effectCount">0</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <button onclick="toggleEffects()" id="toggleEffects">
                üéÜ Effects: ON
            </button>
            <button onclick="clearEffects()">
                üßπ Clear Effects
            </button>
            <button onclick="togglePerformance()">
                ‚ö° Performance Mode
            </button>
        </div>
        
        <div class="tutorial">
            <h2>üéÆ Gesture Effects Guide</h2>
            <div class="gesture-examples">
                <div class="example">
                    <div class="example-icon">‚úã</div>
                    <div>OPEN PALM</div>
                    <small>Creates ripples</small>
                </div>
                <div class="example">
                    <div class="example-icon">‚úåÔ∏è</div>
                    <div>PEACE SIGN</div>
                    <small>Rainbow confetti</small>
                </div>
                <div class="example">
                    <div class="example-icon">üëÜ</div>
                    <div>POINTING</div>
                    <small>Laser beams</small>
                </div>
                <div class="example">
                    <div class="example-icon">ü§ò</div>
                    <div>ROCK ON</div>
                    <small>Purple explosions</small>
                </div>
                <div class="example">
                    <div class="example-icon">‚úä</div>
                    <div>FIST</div>
                    <small>Clears everything</small>
                </div>
                <div class="example">
                    <div class="example-icon">üëç</div>
                    <div>THUMBS UP</div>
                    <small>Golden fireworks</small>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    
    <script>
        // ========== CONFIGURATION ==========
        const CONFIG = {
            width: 640,
            height: 480,
            effectsEnabled: true,
            performanceMode: false,
            maxEffects: 100
        };

        // ========== ELEMENTS ==========
        const video = document.getElementById('videoInput');
        const canvas = document.getElementById('canvasOutput');
        const ctx = canvas.getContext('2d');
        const gestureText = document.getElementById('gestureText');
        const handCount = document.getElementById('handCount');
        const confidence = document.getElementById('confidence');
        const effectCount = document.getElementById('effectCount');
        const effectsOverlay = document.getElementById('effectsOverlay');
        const fpsDisplay = document.getElementById('fps');

        // ========== STATE VARIABLES ==========
        let hands = null;
        let currentStream = null;
        let currentGesture = '';
        let lastGesture = '';
        let effects = [];
        let activeEffects = 0;
        let fps = 0;
        let frameCount = 0;
        let lastFpsTime = 0;

        // ========== INITIALIZATION ==========
        async function init() {
            console.log('üöÄ Starting Magic Hand Gestures...');
            
            try {
                await startCamera();
                await initMediaPipe();
                startFPSMonitor();
                requestAnimationFrame(processFrame);
                
                console.log('‚úÖ Ready! Make some gestures!');
                
            } catch (error) {
                console.error('‚ùå Error:', error);
                gestureText.textContent = '‚ùå Error: ' + error.message;
            }
        }

        // ========== CAMERA ==========
        async function startCamera() {
            const constraints = {
                video: {
                    width: { ideal: CONFIG.width },
                    height: { ideal: CONFIG.height },
                    facingMode: 'user',
                    frameRate: { ideal: 30 }
                }
            };
            
            currentStream = await navigator.mediaDevices.getUserMedia(constraints);
            video.srcObject = currentStream;
            
            return new Promise(resolve => {
                video.onloadedmetadata = () => {
                    video.play();
                    resolve();
                };
            });
        }

        // ========== MEDIAPIPE ==========
        async function initMediaPipe() {
            hands = new self.Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: CONFIG.performanceMode ? 0 : 1,
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.5,
                selfieMode: true
            });
            
            hands.onResults(onResults);
        }

        // ========== PROCESS FRAMES ==========
        function processFrame() {
            if (video.videoWidth > 0 && hands) {
                hands.send({ image: video });
            }
            requestAnimationFrame(processFrame);
        }

        // ========== HANDLE RESULTS ==========
        function onResults(results) {
            // Update FPS
            frameCount++;
            const now = Date.now();
            if (now >= lastFpsTime + 1000) {
                fps = Math.round((frameCount * 1000) / (now - lastFpsTime));
                fpsDisplay.textContent = fps;
                frameCount = 0;
                lastFpsTime = now;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw video (mirrored)
            ctx.save();
            ctx.scale(-1, 1);
            ctx.translate(-canvas.width, 0);
            ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
            ctx.restore();
            
            // Check for hands
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // Draw hand
                drawHand(landmarks);
                
                // Detect gesture
                detectGesture(landmarks);
                
                // Update stats
                handCount.textContent = results.multiHandLandmarks.length;
                
                if (results.multiHandedness && results.multiHandedness[0]) {
                    const conf = results.multiHandedness[0].score * 100;
                    confidence.textContent = `${Math.round(conf)}%`;
                }
                
            } else {
                handCount.textContent = '0';
                confidence.textContent = '0%';
                gestureText.textContent = 'üëã Show your hand!';
            }
            
            // Update effect count
            effectCount.textContent = effects.length;
        }

        // ========== DRAW HAND (SIMPLE & CLEAN) ==========
        function drawHand(landmarks) {
            // Draw connections
            const connections = self.Hands.HAND_CONNECTIONS;
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 3;
            ctx.lineJoin = 'round';
            
            connections.forEach(([start, end]) => {
                const p1 = landmarks[start];
                const p2 = landmarks[end];
                
                let x1 = (1 - p1.x) * canvas.width;
                let y1 = p1.y * canvas.height;
                let x2 = (1 - p2.x) * canvas.width;
                let y2 = p2.y * canvas.height;
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            });
            
            // Draw landmarks as glowing dots
            landmarks.forEach(point => {
                let x = (1 - point.x) * canvas.width;
                let y = point.y * canvas.height;
                
                // Outer glow
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 255, 136, 0.3)';
                ctx.fill();
                
                // Inner dot
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#00ff88';
                ctx.fill();
                
                // Center highlight
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fillStyle = '#ffffff';
                ctx.fill();
            });
        }

        // ========== GESTURE DETECTION ==========
        function detectGesture(landmarks) {
            const tips = [4, 8, 12, 16, 20];
            const bases = [2, 5, 9, 13, 17];
            
            const fingerUp = tips.map((tipIdx, i) => {
                const tip = landmarks[tipIdx];
                const base = landmarks[bases[i]];
                return tip.y < base.y;
            });
            
            const [thumbUp, indexUp, middleUp, ringUp, pinkyUp] = fingerUp;
            
            let gesture = '';
            
            if (indexUp && middleUp && !ringUp && !pinkyUp) {
                gesture = "‚úåÔ∏è Peace Sign";
            } else if (indexUp && !middleUp && !ringUp && !pinkyUp) {
                gesture = "üëÜ Pointing";
            } else if (!indexUp && !middleUp && !ringUp && !pinkyUp) {
                gesture = "‚úä Fist";
            } else if (indexUp && middleUp && ringUp && pinkyUp) {
                gesture = "‚úã Open Palm";
            } else if (indexUp && !middleUp && !ringUp && pinkyUp) {
                gesture = "ü§ò Rock On";
            } else if (thumbUp && !indexUp && !middleUp && !ringUp && !pinkyUp) {
                gesture = "üëç Thumbs Up";
            } else {
                gesture = "‚úã Hand Detected";
            }
            
            // Update display
            if (gesture !== currentGesture) {
                currentGesture = gesture;
                gestureText.textContent = gesture;
                
                // Trigger effects
                if (CONFIG.effectsEnabled && gesture !== lastGesture) {
                    createGestureEffect(gesture, landmarks);
                    lastGesture = gesture;
                }
            }
        }

        // ========== VISUAL EFFECTS ==========
        function createGestureEffect(gesture, landmarks) {
            if (!CONFIG.effectsEnabled) return;
            
            // Get hand position
            const center = landmarks[0];
            const x = (1 - center.x) * window.innerWidth;
            const y = center.y * window.innerHeight;
            
            console.log(`Creating effect for: ${gesture} at (${x.toFixed(0)}, ${y.toFixed(0)})`);
            
            switch(gesture) {
                case "‚úåÔ∏è Peace Sign":
                    createConfetti(x, y);
                    break;
                case "üëÜ Pointing":
                    createLaser(x, y);
                    break;
                case "‚úä Fist":
                    clearEffects();
                    break;
                case "‚úã Open Palm":
                    createRipple(x, y);
                    break;
                case "ü§ò Rock On":
                    createExplosion(x, y, '#ff00ff');
                    break;
                case "üëç Thumbs Up":
                    createFireworks(x, y, '#ffcc00');
                    break;
            }
        }

        // ========== EFFECT FUNCTIONS ==========
        function createConfetti(x, y) {
            console.log('Creating confetti at:', x, y);
            const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];
            
            for (let i = 0; i < 50; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = `${x}px`;
                    confetti.style.top = `${y}px`;
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    
                    effectsOverlay.appendChild(confetti);
                    effects.push(confetti);
                    
                    // Animate
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 100 + Math.random() * 200;
                    const duration = 1000 + Math.random() * 1000;
                    
                    confetti.animate([
                        { 
                            transform: 'translate(0, 0) rotate(0deg)',
                            opacity: 1 
                        },
                        { 
                            transform: `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance + 100}px) rotate(${360}deg)`,
                            opacity: 0 
                        }
                    ], {
                        duration: duration,
                        easing: 'cubic-bezier(0.1, 0.8, 0.9, 0.1)'
                    });
                    
                    // Remove after animation
                    setTimeout(() => {
                        const index = effects.indexOf(confetti);
                        if (index > -1) effects.splice(index, 1);
                        confetti.remove();
                    }, duration);
                    
                }, i * 20);
            }
        }

        function createLaser(x, y) {
            console.log('Creating laser at:', x, y);
            
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const laser = document.createElement('div');
                    laser.className = 'laser';
                    laser.style.left = `${x}px`;
                    laser.style.top = `${y}px`;
                    
                    const angle = Math.random() * Math.PI * 2;
                    const length = 200 + Math.random() * 300;
                    
                    laser.style.width = `${length}px`;
                    laser.style.transform = `rotate(${angle}rad)`;
                    
                    effectsOverlay.appendChild(laser);
                    effects.push(laser);
                    
                    // Animate
                    laser.animate([
                        { opacity: 1, transform: `rotate(${angle}rad) scaleX(1)` },
                        { opacity: 0, transform: `rotate(${angle}rad) scaleX(0)` }
                    ], {
                        duration: 300,
                        easing: 'ease-out'
                    });
                    
                    setTimeout(() => {
                        const index = effects.indexOf(laser);
                        if (index > -1) effects.splice(index, 1);
                        laser.remove();
                    }, 300);
                    
                }, i * 100);
            }
        }

        function createRipple(x, y) {
            console.log('Creating ripple at:', x, y);
            
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const ripple = document.createElement('div');
                    ripple.className = 'ripple';
                    ripple.style.left = `${x}px`;
                    ripple.style.top = `${y}px`;
                    ripple.style.borderColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
                    
                    effectsOverlay.appendChild(ripple);
                    effects.push(ripple);
                    
                    setTimeout(() => {
                        const index = effects.indexOf(ripple);
                        if (index > -1) effects.splice(index, 1);
                        ripple.remove();
                    }, 1000);
                    
                }, i * 200);
            }
        }

        function createExplosion(x, y, color) {
            console.log('Creating explosion at:', x, y);
            
            for (let i = 0; i < 30; i++) {
                setTimeout(() => {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.left = `${x}px`;
                    particle.style.top = `${y}px`;
                    particle.style.width = `${10 + Math.random() * 10}px`;
                    particle.style.height = particle.style.width;
                    particle.style.backgroundColor = color;
                    
                    effectsOverlay.appendChild(particle);
                    effects.push(particle);
                    
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 50 + Math.random() * 150;
                    const duration = 800 + Math.random() * 800;
                    
                    particle.animate([
                        { 
                            transform: 'translate(0, 0) scale(1)',
                            opacity: 1 
                        },
                        { 
                            transform: `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px) scale(0)`,
                            opacity: 0 
                        }
                    ], {
                        duration: duration,
                        easing: 'ease-out'
                    });
                    
                    setTimeout(() => {
                        const index = effects.indexOf(particle);
                        if (index > -1) effects.splice(index, 1);
                        particle.remove();
                    }, duration);
                    
                }, i * 20);
            }
        }

        function createFireworks(x, y, color) {
            console.log('Creating fireworks at:', x, y);
            
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const firework = document.createElement('div');
                    firework.className = 'firework';
                    firework.style.left = `${x}px`;
                    firework.style.top = `${y}px`;
                    firework.style.backgroundColor = color;
                    firework.style.boxShadow = `0 0 10px ${color}`;
                    
                    effectsOverlay.appendChild(firework);
                    effects.push(firework);
                    
                    const targetX = x + (Math.random() - 0.5) * 300;
                    const targetY = y - 100 - Math.random() * 200;
                    
                    // Launch
                    firework.animate([
                        { transform: 'translate(0, 0)', opacity: 1 },
                        { transform: `translate(${targetX - x}px, ${targetY - y}px)`, opacity: 1 }
                    ], {
                        duration: 500,
                        easing: 'ease-out'
                    });
                    
                    // Explode after reaching top
                    setTimeout(() => {
                        createExplosion(targetX, targetY, color);
                        firework.remove();
                        const index = effects.indexOf(firework);
                        if (index > -1) effects.splice(index, 1);
                    }, 500);
                    
                }, i * 200);
            }
        }

        // ========== EFFECTS MANAGEMENT ==========
        function clearEffects() {
            console.log('Clearing all effects');
            effects.forEach(effect => effect.remove());
            effects = [];
            effectsOverlay.innerHTML = '';
        }

        function toggleEffects() {
            CONFIG.effectsEnabled = !CONFIG.effectsEnabled;
            const button = document.getElementById('toggleEffects');
            button.textContent = CONFIG.effectsEnabled ? 'üéÜ Effects: ON' : 'üéÜ Effects: OFF';
            
            if (!CONFIG.effectsEnabled) {
                clearEffects();
            }
            
            console.log('Effects enabled:', CONFIG.effectsEnabled);
        }

        function togglePerformance() {
            CONFIG.performanceMode = !CONFIG.performanceMode;
            initMediaPipe(); // Reinitialize with new settings
        }

        // ========== FPS MONITOR ==========
        function startFPSMonitor() {
            setInterval(() => {
                // Clean up old effects if too many
                if (effects.length > CONFIG.maxEffects) {
                    const toRemove = effects.splice(0, effects.length - CONFIG.maxEffects);
                    toRemove.forEach(effect => effect.remove());
                }
            }, 1000);
        }

        // ========== START EVERYTHING ==========
        window.addEventListener('load', init);
    </script>
</body>
</html>