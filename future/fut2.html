<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magical Ghibli Spirit Tree</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, tree = {}, time = 0;
        
        function init() {
            scene = new THREE.Scene();
            
            const skyGradient = createSkyGradient();
            scene.background = skyGradient;
            scene.fog = new THREE.Fog(0x8b6f9e, 30, 80);
            
            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 12, 28);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);
            
            setupMagicalLighting();
            createSpiritTree();
            createMagicalWorld();
            
            window.addEventListener('resize', onResize);
            animate();
        }
        
        function createSkyGradient() {
            const canvas = document.createElement('canvas');
            canvas.width = 2;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createLinearGradient(0, 0, 0, 256);
            gradient.addColorStop(0, '#1a0f2e');
            gradient.addColorStop(0.3, '#3d2352');
            gradient.addColorStop(0.6, '#7a4d7e');
            gradient.addColorStop(0.8, '#c9a0dc');
            gradient.addColorStop(1, '#ffd4a3');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 2, 256);
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }
        
        function setupMagicalLighting() {
            const ambient = new THREE.AmbientLight(0x5a4a6a, 0.5);
            scene.add(ambient);
            
            const sunLight = new THREE.DirectionalLight(0xffd68f, 3);
            sunLight.position.set(20, 15, 10);
            scene.add(sunLight);
            
            const moonLight = new THREE.DirectionalLight(0x9b7fb5, 1.5);
            moonLight.position.set(-15, 10, -10);
            scene.add(moonLight);
            
            const magicLight1 = new THREE.PointLight(0x7fffd4, 4, 35);
            magicLight1.position.set(0, 18, 0);
            scene.add(magicLight1);
            tree.magicLight1 = magicLight1;
            
            const magicLight2 = new THREE.PointLight(0xff69b4, 3, 30);
            magicLight2.position.set(5, 10, 5);
            scene.add(magicLight2);
            tree.magicLight2 = magicLight2;
            
            const magicLight3 = new THREE.PointLight(0x98fb98, 3, 30);
            magicLight3.position.set(-5, 12, -5);
            scene.add(magicLight3);
            tree.magicLight3 = magicLight3;
        }
        
        function createSpiritTree() {
            tree.trunk = [];
            tree.branches = [];
            tree.leaves = [];
            tree.grass = [];
            tree.flowers = [];
            
            createMagicalGround();
            createTwistedTrunk();
            createSpreadingBranches();
            createMagicalCanopy();
        }
        
        function createMagicalGround() {
            const groundGeo = new THREE.CircleGeometry(20, 64);
            const groundMat = new THREE.MeshStandardMaterial({ 
                color: 0x2a4d2a,
                flatShading: false,
                roughness: 0.9
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            scene.add(ground);
            
            for (let i = 0; i < 1500; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 2 + Math.random() * 16;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                const height = 0.2 + Math.random() * 0.5;
                const geo = new THREE.ConeGeometry(0.03, height, 3);
                
                const hue = 0.3 + Math.random() * 0.15;
                const sat = 0.6 + Math.random() * 0.3;
                const light = 0.4 + Math.random() * 0.3;
                const color = new THREE.Color().setHSL(hue, sat, light);
                
                const mat = new THREE.MeshStandardMaterial({ 
                    color: color,
                    flatShading: true,
                    emissive: color,
                    emissiveIntensity: 0.1
                });
                const blade = new THREE.Mesh(geo, mat);
                blade.position.set(x, height / 2, z);
                blade.rotation.z = (Math.random() - 0.5) * 0.5;
                blade.rotation.y = Math.random() * Math.PI * 2;
                
                blade.userData = {
                    baseRotZ: blade.rotation.z,
                    offset: Math.random() * Math.PI * 2,
                    speed: 0.3 + Math.random() * 0.5,
                    amp: 0.15 + Math.random() * 0.2
                };
                
                scene.add(blade);
                tree.grass.push(blade);
            }
            
            for (let i = 0; i < 80; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 3 + Math.random() * 10;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                const flowerGeo = new THREE.SphereGeometry(0.08, 6, 6);
                const hue = Math.random();
                const flowerColor = new THREE.Color().setHSL(hue, 0.9, 0.6);
                const flowerMat = new THREE.MeshStandardMaterial({ 
                    color: flowerColor,
                    flatShading: true,
                    emissive: flowerColor,
                    emissiveIntensity: 0.4
                });
                const flower = new THREE.Mesh(flowerGeo, flowerMat);
                flower.position.set(x, 0.2, z);
                
                flower.userData = {
                    baseY: 0.2,
                    offset: Math.random() * Math.PI * 2,
                    speed: 1 + Math.random() * 1.5
                };
                
                scene.add(flower);
                tree.flowers.push(flower);
            }
        }
        
        function createTwistedTrunk() {
            const trunkHeight = 11;
            const segments = 30;
            const twistAmount = Math.PI * 3;
            
            for (let i = 0; i < segments; i++) {
                const t = i / segments;
                const nextT = (i + 1) / segments;
                
                const spiralRadius = 0.3;
                const twist = t * twistAmount;
                const nextTwist = nextT * twistAmount;
                
                const baseRadius = 1.0;
                const topRadius = 0.4;
                const radius = baseRadius - (baseRadius - topRadius) * Math.pow(t, 0.8);
                const nextRadius = baseRadius - (baseRadius - topRadius) * Math.pow(nextT, 0.8);
                
                const bulgeFactor = Math.sin(t * Math.PI * 4) * 0.15;
                const finalRadius = radius + bulgeFactor;
                const finalNextRadius = nextRadius + Math.sin(nextT * Math.PI * 4) * 0.15;
                
                const x = Math.cos(twist) * spiralRadius * t;
                const z = Math.sin(twist) * spiralRadius * t;
                const nextX = Math.cos(nextTwist) * spiralRadius * nextT;
                const nextZ = Math.sin(nextTwist) * spiralRadius * nextT;
                
                const y = t * trunkHeight;
                const nextY = nextT * trunkHeight;
                
                const height = trunkHeight / segments;
                const geo = new THREE.CylinderGeometry(finalNextRadius, finalRadius, height, 10);
                
                const barkHue = 0.08 + Math.random() * 0.05;
                const barkColor = new THREE.Color().setHSL(barkHue, 0.4, 0.2 + Math.random() * 0.1);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: barkColor,
                    flatShading: true,
                    roughness: 0.95
                });
                
                const seg = new THREE.Mesh(geo, mat);
                seg.position.set(
                    (x + nextX) / 2,
                    y + height / 2,
                    (z + nextZ) / 2
                );
                
                const midTwist = (twist + nextTwist) / 2;
                seg.rotation.y = midTwist;
                
                const tiltAngle = Math.atan2(nextX - x, height) * 0.5;
                seg.rotation.z = tiltAngle;
                
                seg.userData = {
                    basePos: seg.position.clone(),
                    baseRotY: seg.rotation.y,
                    baseRotZ: seg.rotation.z,
                    offset: i * 0.3,
                    breatheAmp: 0.02 + Math.random() * 0.015,
                    breatheSpeed: 0.6 + Math.random() * 0.4
                };
                
                scene.add(seg);
                tree.trunk.push(seg);
                
                if (i > 5 && i % 5 === 0 && Math.random() > 0.5) {
                    const knotSize = finalRadius * (0.4 + Math.random() * 0.3);
                    const knotGeo = new THREE.SphereGeometry(knotSize, 7, 7);
                    const knot = new THREE.Mesh(knotGeo, mat);
                    knot.position.copy(seg.position);
                    knot.position.x += finalRadius * 0.7;
                    scene.add(knot);
                }
            }
        }
        
        function createSpreadingBranches() {
            const branchLevels = 5;
            const branchesPerLevel = 8;
            
            for (let level = 0; level < branchLevels; level++) {
                const levelHeight = 7 + level * 1.2;
                const levelAngleOffset = level * 0.4;
                
                for (let i = 0; i < branchesPerLevel; i++) {
                    const angle = (i / branchesPerLevel) * Math.PI * 2 + levelAngleOffset;
                    const length = 4.5 + Math.random() * 2;
                    const spread = 1.2 + level * 0.3;
                    createSpreadingBranch(angle, levelHeight, 0, length, 0.22, spread);
                }
            }
        }
        
        function createSpreadingBranch(angle, startY, gen, len, thickness, spread) {
            if (gen > 2 || len < 1) return;
            
            const points = [];
            const segments = 15;
            const upwardCurve = 0.5 - gen * 0.2;
            
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const radius = t * len * spread;
                const lift = Math.pow(t, upwardCurve) * (3 - gen * 1) - t * 0.8;
                const droop = Math.pow(t, 2) * 0.5;
                const wave = Math.sin(t * Math.PI * 2) * 0.3;
                
                points.push(new THREE.Vector3(
                    Math.cos(angle) * radius + wave,
                    startY + lift - droop,
                    Math.sin(angle) * radius
                ));
            }
            
            const curve = new THREE.CatmullRomCurve3(points);
            const geo = new THREE.TubeGeometry(curve, segments, thickness - gen * 0.06, 8, false);
            
            const branchHue = 0.08 + Math.random() * 0.04;
            const mat = new THREE.MeshStandardMaterial({ 
                color: new THREE.Color().setHSL(branchHue, 0.35, 0.25),
                flatShading: true,
                roughness: 0.9
            });
            const branch = new THREE.Mesh(geo, mat);
            
            branch.userData = {
                offset: Math.random() * Math.PI * 2,
                breatheSpeed: 0.35 + Math.random() * 0.25,
                breatheAmp: 0.03 + Math.random() * 0.02
            };
            
            scene.add(branch);
            tree.branches.push(branch);
            
            if (gen < 2) {
                const subBranches = 3 + Math.floor(Math.random() * 2);
                for (let i = 0; i < subBranches; i++) {
                    const splitT = 0.6 + Math.random() * 0.3;
                    const splitPoint = curve.getPointAt(splitT);
                    const newAngle = angle + (Math.random() - 0.5) * 1.5;
                    createSpreadingBranch(newAngle, splitPoint.y, gen + 1, len * 0.65, thickness * 0.75, spread * 0.8);
                }
            }
        }
        
        function createMagicalCanopy() {
            const radialRings = 12;
            const heightLayers = 18;
            
            for (let layer = 0; layer < heightLayers; layer++) {
                const layerT = layer / heightLayers;
                const baseY = 9 + layer * 0.9;
                const maxRadius = 9 + Math.sin(layerT * Math.PI) * 2;
                const density = 15 + Math.floor(layerT * 25);
                
                for (let ring = 0; ring < radialRings; ring++) {
                    const ringT = ring / radialRings;
                    const radius = maxRadius * ringT * (0.5 + Math.random() * 0.5);
                    
                    for (let i = 0; i < density; i++) {
                        const angle = (i / density) * Math.PI * 2 + layer * 0.5 + ring * 0.3;
                        const r = radius + (Math.random() - 0.5) * 1.5;
                        const x = Math.cos(angle) * r;
                        const z = Math.sin(angle) * r;
                        const y = baseY + (Math.random() - 0.5) * 1.5;
                        
                        const clusterSize = 4 + Math.floor(Math.random() * 6);
                        for (let c = 0; c < clusterSize; c++) {
                            const leafSize = 0.35 + Math.random() * 0.65;
                            const geo = new THREE.SphereGeometry(leafSize, 6, 6);
                            
                            const leafType = Math.random();
                            let leafColor;
                            if (leafType < 0.4) {
                                leafColor = new THREE.Color().setHSL(0.32 + Math.random() * 0.08, 0.75, 0.5);
                            } else if (leafType < 0.7) {
                                leafColor = new THREE.Color().setHSL(0.42 + Math.random() * 0.08, 0.7, 0.55);
                            } else if (leafType < 0.85) {
                                leafColor = new THREE.Color().setHSL(0.52 + Math.random() * 0.08, 0.65, 0.6);
                            } else {
                                leafColor = new THREE.Color().setHSL(0.15 + Math.random() * 0.1, 0.8, 0.65);
                            }
                            
                            const mat = new THREE.MeshStandardMaterial({ 
                                color: leafColor,
                                flatShading: true,
                                roughness: 0.7,
                                emissive: leafColor,
                                emissiveIntensity: 0.25 + Math.random() * 0.15
                            });
                            
                            const leaf = new THREE.Mesh(geo, mat);
                            leaf.position.set(
                                x + (Math.random() - 0.5) * 2,
                                y + (Math.random() - 0.5) * 1.5,
                                z + (Math.random() - 0.5) * 2
                            );
                            
                            const scaleVar = 0.7 + Math.random() * 0.6;
                            leaf.scale.set(
                                scaleVar * (0.8 + Math.random() * 0.4),
                                scaleVar * (1 + Math.random() * 0.5),
                                scaleVar * (0.8 + Math.random() * 0.4)
                            );
                            
                            leaf.userData = {
                                basePos: leaf.position.clone(),
                                baseScale: leaf.scale.clone(),
                                offset: Math.random() * Math.PI * 2,
                                breatheSpeed: 0.4 + Math.random() * 0.9,
                                breatheAmp: 0.3 + Math.random() * 0.5,
                                pulseSpeed: 0.7 + Math.random() * 1.5,
                                pulseAmp: 0.15 + Math.random() * 0.2,
                                glowSpeed: 0.5 + Math.random() * 1
                            };
                            
                            scene.add(leaf);
                            tree.leaves.push(leaf);
                        }
                    }
                }
            }
        }
        
        function createMagicalWorld() {
            tree.spirits = [];
            tree.sparkles = [];
            
            for (let i = 0; i < 150; i++) {
                const geo = new THREE.SphereGeometry(0.08, 8, 8);
                const hue = Math.random();
                const mat = new THREE.MeshBasicMaterial({ 
                    color: new THREE.Color().setHSL(hue, 1, 0.7),
                    transparent: true
                });
                const spirit = new THREE.Mesh(geo, mat);
                
                spirit.position.set(
                    (Math.random() - 0.5) * 30,
                    Math.random() * 20,
                    (Math.random() - 0.5) * 30
                );
                
                spirit.userData = {
                    vel: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.02,
                        0.01 + Math.random() * 0.03,
                        (Math.random() - 0.5) * 0.02
                    ),
                    offset: Math.random() * Math.PI * 2,
                    pulseSpeed: 2 + Math.random() * 3
                };
                
                scene.add(spirit);
                tree.spirits.push(spirit);
            }
            
            for (let i = 0; i < 60; i++) {
                const geo = new THREE.SphereGeometry(0.12, 8, 8);
                const hue = Math.random();
                const mat = new THREE.MeshBasicMaterial({ 
                    color: new THREE.Color().setHSL(hue, 0.9, 0.8),
                    transparent: true
                });
                const sparkle = new THREE.Mesh(geo, mat);
                
                const angle = Math.random() * Math.PI * 2;
                const radius = 5 + Math.random() * 8;
                const height = 5 + Math.random() * 12;
                
                sparkle.position.set(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );
                
                sparkle.userData = {
                    angle: angle,
                    radius: radius,
                    height: height,
                    speed: 0.1 + Math.random() * 0.2,
                    vertSpeed: 0.2 + Math.random() * 0.3,
                    offset: Math.random() * Math.PI * 2,
                    pulseSpeed: 1.5 + Math.random() * 2.5
                };
                
                scene.add(sparkle);
                tree.sparkles.push(sparkle);
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;
            
            const globalBreath = Math.sin(time * 0.5) * 0.5 + 0.5;
            
            tree.trunk.forEach(seg => {
                const d = seg.userData;
                const breath = Math.sin(time * d.breatheSpeed + d.offset);
                
                seg.rotation.z = d.baseRotZ + breath * d.breatheAmp;
                seg.rotation.y = d.baseRotY + Math.cos(time * 0.35 + d.offset) * 0.02;
                
                const wobble = Math.sin(time * 0.4 + d.offset) * 0.04;
                seg.position.x = d.basePos.x + wobble;
                seg.position.z = d.basePos.z + Math.cos(time * 0.3 + d.offset) * 0.03;
                
                const scale = 1 + breath * d.breatheAmp * 3;
                seg.scale.set(scale, 1 + breath * d.breatheAmp, scale);
            });
            
            tree.branches.forEach(branch => {
                const d = branch.userData;
                const breath = Math.sin(time * d.breatheSpeed + d.offset);
                branch.rotation.x = breath * d.breatheAmp * 1.5;
                branch.rotation.z = Math.cos(time * d.breatheSpeed * 0.7 + d.offset) * d.breatheAmp;
            });
            
            tree.leaves.forEach(leaf => {
                const d = leaf.userData;
                const breath = Math.sin(time * d.breatheSpeed + d.offset);
                const swayX = breath * d.breatheAmp;
                const swayY = Math.cos(time * d.breatheSpeed * 0.8 + d.offset) * d.breatheAmp * 0.8;
                const swayZ = Math.sin(time * d.breatheSpeed * 0.6 + d.offset + 2) * d.breatheAmp;
                
                leaf.position.x = d.basePos.x + swayX;
                leaf.position.y = d.basePos.y + swayY;
                leaf.position.z = d.basePos.z + swayZ;
                
                const pulse = 1 + Math.sin(time * d.pulseSpeed + d.offset) * d.pulseAmp;
                leaf.scale.x = d.baseScale.x * pulse;
                leaf.scale.y = d.baseScale.y * pulse;
                leaf.scale.z = d.baseScale.z * pulse;
                
                const glow = 0.25 + Math.sin(time * d.glowSpeed + d.offset) * 0.15;
                leaf.material.emissiveIntensity = glow;
            });
            
            tree.grass.forEach(blade => {
                const sway = Math.sin(time * blade.userData.speed + blade.userData.offset) * blade.userData.amp;
                blade.rotation.z = blade.userData.baseRotZ + sway;
            });
            
            tree.flowers.forEach(flower => {
                const bob = Math.sin(time * flower.userData.speed + flower.userData.offset) * 0.1;
                flower.position.y = flower.userData.baseY + bob;
                const glow = 0.4 + Math.sin(time * 2 + flower.userData.offset) * 0.3;
                flower.material.emissiveIntensity = glow;
            });
            
            tree.spirits.forEach(spirit => {
                spirit.position.add(spirit.userData.vel);
                
                if (spirit.position.y > 22) spirit.position.y = -2;
                if (Math.abs(spirit.position.x) > 18) spirit.userData.vel.x *= -1;
                if (Math.abs(spirit.position.z) > 18) spirit.userData.vel.z *= -1;
                
                const pulse = 0.3 + Math.sin(time * spirit.userData.pulseSpeed + spirit.userData.offset) * 0.7;
                spirit.material.opacity = pulse;
                spirit.scale.setScalar(0.6 + pulse * 0.6);
            });
            
            tree.sparkles.forEach(sparkle => {
                const d = sparkle.userData;
                sparkle.position.x = Math.cos(time * d.speed + d.angle) * d.radius;
                sparkle.position.z = Math.sin(time * d.speed + d.angle) * d.radius;
                sparkle.position.y = d.height + Math.sin(time * d.vertSpeed + d.offset) * 2;
                
                const pulse = 0.2 + Math.sin(time * d.pulseSpeed + d.offset) * 0.8;
                sparkle.material.opacity = pulse;
                sparkle.scale.setScalar(0.5 + pulse * 0.8);
            });
            
            if (tree.magicLight1) {
                tree.magicLight1.intensity = 4 + Math.sin(time * 0.9) * 1.5;
                tree.magicLight1.position.y = 18 + Math.sin(time * 0.4) * 2;
            }
            
            if (tree.magicLight2) {
                tree.magicLight2.intensity = 3 + Math.cos(time * 1.2) * 1;
            }
            
            if (tree.magicLight3) {
                tree.magicLight3.intensity = 3 + Math.sin(time * 0.8 + 1) * 1;
            }
            
            const camAngle = time * 0.035;
            camera.position.x = Math.cos(camAngle) * 28;
            camera.position.z = Math.sin(camAngle) * 28;
            camera.position.y = 12 + Math.sin(time * 0.2) * 2;
            camera.lookAt(0, 11, 0);
            
            renderer.render(scene, camera);
        }
        
        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        init();
    </script>
</body>
</html>