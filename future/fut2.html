<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mononoke's Living Spirit Tree</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            margin: 0;
            overflow: hidden;
            background: #050c0f;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #C8F0E8;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(10, 26, 26, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(155, 224, 216, 0.3);
            max-width: 300px;
            backdrop-filter: blur(5px);
        }
        
        #ui h2 {
            color: #9BE0D8;
            margin-bottom: 10px;
            font-size: 1.2em;
        }
        
        #ui p {
            font-size: 0.9em;
            margin-bottom: 8px;
            line-height: 1.4;
        }
        
        .control-group {
            margin: 15px 0;
        }
        
        button {
            background: rgba(74, 113, 89, 0.7);
            border: 1px solid #5AB4B4;
            color: #C8F0E8;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
            transition: all 0.3s;
            font-size: 0.9em;
        }
        
        button:hover {
            background: rgba(90, 180, 180, 0.5);
            transform: translateY(-1px);
        }
        
        .slider-container {
            margin: 10px 0;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        
        input[type="range"] {
            width: 100%;
        }
        
        #camera-feed {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border-radius: 10px;
            border: 2px solid rgba(155, 224, 216, 0.5);
            overflow: hidden;
            z-index: 100;
            opacity: 0.8;
        }
        
        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 1000;
        }
        
        .spinner {
            border: 3px solid rgba(155, 224, 216, 0.3);
            border-top: 3px solid #9BE0D8;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-active {
            background: #4CAF50;
            box-shadow: 0 0 10px #4CAF50;
        }
        
        .status-inactive {
            background: #f44336;
        }
        
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading">
        <div class="spinner"></div>
        <p>Summoning the Forest Spirits...</p>
        <p id="loading-text">Initializing Magic...</p>
    </div>
    
    <!-- UI Panel -->
    <div id="ui" style="display: none;">
        <h2>üå≥ Spirit Forest Controls</h2>
        
        <div class="control-group">
            <p><span class="status-indicator" id="webcam-status"></span> Webcam: <span id="webcam-text">Loading...</span></p>
            <p><span class="status-indicator" id="mediapipe-status"></span> MediaPipe: <span id="mediapipe-text">Loading...</span></p>
        </div>
        
        <div class="control-group">
            <p><strong>Interactions:</strong></p>
            <p>üëê Open hand ‚Üí Brighten spirits</p>
            <p>‚úã Peace sign ‚Üí Create fireflies</p>
            <p>üëÅÔ∏è Blink eyes ‚Üí Kodama attention</p>
            <p>üòÆ Open mouth ‚Üí Gentle breeze</p>
        </div>
        
        <div class="control-group">
            <button id="day-night">Cycle Day/Night</button>
            <button id="toggle-sound">üîá Sound Off</button>
            <button id="reset-tree">Reset Tree</button>
        </div>
        
        <div class="slider-container">
            <label>Spirit Brightness: <span id="brightness-value">50%</span></label>
            <input type="range" id="brightness-slider" min="0" max="100" value="50">
        </div>
        
        <div class="slider-container">
            <label>Tree Animation: <span id="animation-value">50%</span></label>
            <input type="range" id="animation-slider" min="0" max="100" value="50">
        </div>
        
        <p id="current-interaction">No active interaction</p>
    </div>
    
    <!-- Camera Feed -->
    <div id="camera-feed" style="display: none;">
        <video id="video" playsinline></video>
        <canvas id="output-canvas" style="position: absolute; top: 0; left: 0;"></canvas>
    </div>
    
    <!-- Three.js Canvas will be injected here -->
    
    <!-- Audio Elements -->
    <audio id="ambience" loop>
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-forest-ambience-977.mp3" type="audio/mpeg">
    </audio>
    <audio id="spirit-sound">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-magic-sparkle-sound-309.mp3" type="audio/mpeg">
    </audio>
    <audio id="wind-sound">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-wind-whistling-1490.mp3" type="audio/mpeg">
    </audio>

    <!-- Three.js & Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Post-processing -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <!-- MediaPipe from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    
    <script>
        // ===================== CONFIGURATION =====================
        const CONFIG = {
            // Colors - Mononoke palette
            COLORS: {
                WOOD_LIGHT: 0xB8945F,
                WOOD: 0x8C5E3A,
                WOOD_DARK: 0x5A3C1F,
                LEAF_LIGHT: 0x6D9A7A,
                LEAF_MED: 0x4A7159,
                LEAF_DARK: 0x2F4A3A,
                MOSS: 0x3A5D4E,
                GRASS: 0x567D66,
                FIELD: 0x2C4135,
                SPIRIT_LIGHT: 0x9BE0D8,
                SPIRIT_MED: 0x5AB4B4,
                KODAMA_GLOW: 0xC8F0E8,
                DAY_SKY: 0x87CEEB,
                NIGHT_SKY: 0x0A1A2A
            },
            
            // Performance settings
            PERFORMANCE: {
                LEAF_COUNT: 3000,      // Using InstancedMesh for performance
                GRASS_COUNT: 1500,
                FIREFLIES: 120,
                PARTICLES: 200,
                KODAMAS: 8,
                SPIRITS: 30
            },
            
            // MediaPipe settings
            MEDIAPIPE: {
                HANDS: {
                    maxNumHands: 2,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                },
                FACE: {
                    maxNumFaces: 1,
                    refineLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                }
            },
            
            // Animation speeds
            ANIMATION: {
                BREATHE_SPEED: 0.5,
                WIND_STRENGTH: 0.5,
                DAY_NIGHT_CYCLE: 120 // seconds for full cycle
            }
        };

        // ===================== GLOBAL VARIABLES =====================
        let scene, camera, renderer, composer, bloomPass;
        let tree = { trunk: [], branches: [], leaves: [], grass: [], platforms: [], 
                     fireflies: [], spirits: [], kodamas: [], particles: [] };
        let time = 0, dayNightProgress = 0.3; // Start at dawn
        let isDay = false, isSoundOn = true, animationStrength = 0.5;
        
        // MediaPipe
        let hands, faceMesh, cameraInstance;
        let videoElement, canvasElement, canvasCtx;
        let lastHandDetection = 0, lastFaceDetection = 0;
        let currentInteraction = "none";
        let interactionTimeout = null;
        
        // Instanced meshes
        let leafInstances, grassInstances;
        let leafDummy = new THREE.Object3D();
        let grassDummy = new THREE.Object3D();
        
        // ===================== INITIALIZATION =====================
        async function init() {
            updateLoadingText("Creating magical forest...");
            await initThreeJS();
            updateLoadingText("Summoning tree spirits...");
            await createLivingTree();
            updateLoadingText("Preparing camera magic...");
            await initMediaPipe();
            updateLoadingText("Adding final enchantments...");
            initUI();
            initAudio();
            startAnimations();
            
            // Hide loading, show UI
            document.getElementById('loading').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('camera-feed').style.display = 'block';
        }

        function initThreeJS() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(CONFIG.COLORS.NIGHT_SKY, 10, 50);
            
            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 35);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(CONFIG.COLORS.NIGHT_SKY, 1);
            document.body.appendChild(renderer.domElement);
            
            // Post-processing for Ghibli glow
            composer = new THREE.EffectComposer(renderer);
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);
            
            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.0, 0.4, 0.85
            );
            composer.addPass(bloomPass);
            
            setupLighting();
            createSky();
            
            window.addEventListener('resize', onResize);
        }

        function setupLighting() {
            // Ambient
            const ambient = new THREE.AmbientLight(0x1A2A2A, 0.3);
            scene.add(ambient);
            
            // Moonlight
            const moonLight = new THREE.DirectionalLight(0x5A7A9A, 0.7);
            moonLight.position.set(20, 30, 15);
            moonLight.castShadow = true;
            moonLight.shadow.mapSize.width = 2048;
            moonLight.shadow.mapSize.height = 2048;
            moonLight.shadow.camera.near = 0.5;
            moonLight.shadow.camera.far = 50;
            moonLight.shadow.camera.left = -30;
            moonLight.shadow.camera.right = 30;
            moonLight.shadow.camera.top = 30;
            moonLight.shadow.camera.bottom = -30;
            scene.add(moonLight);
            tree.moonLight = moonLight;
            
            // Sunlight (for day)
            const sunLight = new THREE.DirectionalLight(0xFFF0B0, 0);
            sunLight.position.set(-20, 40, -10);
            sunLight.castShadow = true;
            scene.add(sunLight);
            tree.sunLight = sunLight;
            
            // Spirit glow
            const spiritGlow = new THREE.PointLight(CONFIG.COLORS.SPIRIT_LIGHT, 2, 40);
            spiritGlow.position.set(0, 20, 0);
            scene.add(spiritGlow);
            tree.spiritGlow = spiritGlow;
            
            // Fill light
            const fillLight = new THREE.HemisphereLight(0x2A4A4A, 0x1A2A2A, 0.3);
            scene.add(fillLight);
        }

        function createSky() {
            // Sky gradient using a large sphere
            const skyGeometry = new THREE.SphereGeometry(100, 32, 32);
            const skyMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: new THREE.Color(CONFIG.COLORS.NIGHT_SKY) },
                    bottomColor: { value: new THREE.Color(0x050c0f) },
                    offset: { value: 33 },
                    exponent: { value: 0.6 }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    uniform float offset;
                    uniform float exponent;
                    varying vec3 vWorldPosition;
                    void main() {
                        float h = normalize(vWorldPosition + offset).y;
                        gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                    }
                `,
                side: THREE.BackSide
            });
            
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);
            tree.sky = sky;
        }

        // ===================== TREE CREATION =====================
        function createLivingTree() {
            createGround();
            createOrganicTrunk();
            createBranchNetwork();
            createBreathingCanopy();
            createMagicalEffects();
            createShrine();
        }

        function createGround() {
            // Forest floor with texture
            const groundGeo = new THREE.CircleGeometry(25, 64);
            const groundMat = new THREE.MeshStandardMaterial({
                color: CONFIG.COLORS.FIELD,
                roughness: 0.95,
                metalness: 0.1
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.5;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Moss patches using instancing for performance
            const mossGeo = new THREE.SphereGeometry(1, 8, 6);
            const mossMat = new THREE.MeshStandardMaterial({
                color: CONFIG.COLORS.MOSS,
                roughness: 0.9,
                emissive: CONFIG.COLORS.MOSS,
                emissiveIntensity: 0.05
            });
            
            const mossCount = 100;
            const mossInstances = new THREE.InstancedMesh(mossGeo, mossMat, mossCount);
            
            for (let i = 0; i < mossCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 3 + Math.random() * 20;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const y = Math.random() * 0.3;
                const scale = 0.5 + Math.random() * 1.5;
                
                mossDummy.position.set(x, y, z);
                mossDummy.scale.set(scale, scale * 0.3, scale);
                mossDummy.rotation.y = Math.random() * Math.PI;
                mossDummy.updateMatrix();
                mossInstances.setMatrixAt(i, mossDummy.matrix);
                
                // Store instance data for animation
                mossInstances.instanceMatrix.needsUpdate = true;
            }
            scene.add(mossInstances);
            tree.moss = mossInstances;
            
            // Grass using instanced geometry
            const grassGeo = new THREE.ConeGeometry(0.02, 0.4, 4);
            const grassMat = new THREE.MeshStandardMaterial({
                color: CONFIG.COLORS.GRASS,
                roughness: 0.95,
                emissive: CONFIG.COLORS.GRASS,
                emissiveIntensity: 0.03
            });
            
            grassInstances = new THREE.InstancedMesh(grassGeo, grassMat, CONFIG.PERFORMANCE.GRASS_COUNT);
            
            for (let i = 0; i < CONFIG.PERFORMANCE.GRASS_COUNT; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 2 + Math.random() * 21;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const scale = 0.7 + Math.random() * 0.6;
                
                grassDummy.position.set(x, 0, z);
                grassDummy.rotation.z = (Math.random() - 0.5) * 0.3;
                grassDummy.rotation.y = Math.random() * Math.PI * 2;
                grassDummy.scale.setScalar(scale);
                grassDummy.updateMatrix();
                grassInstances.setMatrixAt(i, grassDummy.matrix);
                
                // Store per-instance data
                const data = {
                    offset: Math.random() * Math.PI * 2,
                    speed: 0.3 + Math.random() * 0.7,
                    amp: 0.1 + Math.random() * 0.2,
                    baseX: x,
                    baseZ: z
                };
                
                if (!grassInstances.userData.instances) {
                    grassInstances.userData.instances = [];
                }
                grassInstances.userData.instances[i] = data;
            }
            grassInstances.instanceMatrix.needsUpdate = true;
            scene.add(grassInstances);
            tree.grassInstances = grassInstances;
        }

        function createOrganicTrunk() {
            const trunkHeight = 14;
            const segments = 32;
            
            // Create bark texture with more character
            const barkCanvas = document.createElement('canvas');
            barkCanvas.width = 512;
            barkCanvas.height = 1024;
            const bctx = barkCanvas.getContext('2d');
            
            // Base color
            bctx.fillStyle = '#8C5E3A';
            bctx.fillRect(0, 0, barkCanvas.width, barkCanvas.height);
            
            // Vertical grooves - more pronounced
            for (let x = 0; x < barkCanvas.width; x += 3) {
                const grooveWidth = 1 + Math.random() * 4;
                const shade = Math.floor(Math.random() * 70);
                bctx.fillStyle = `rgb(${0x5A - shade}, ${0x3C - shade}, ${0x1F - shade})`;
                bctx.fillRect(x, 0, grooveWidth, barkCanvas.height);
            }
            
            // Moss patches on one side (north facing)
            bctx.fillStyle = '#3A5D4E';
            for (let i = 0; i < 50; i++) {
                const x = barkCanvas.width * 0.7 + Math.random() * barkCanvas.width * 0.3;
                const y = Math.random() * barkCanvas.height;
                const size = 10 + Math.random() * 30;
                bctx.beginPath();
                bctx.arc(x, y, size, 0, Math.PI * 2);
                bctx.fill();
            }
            
            const barkTexture = new THREE.CanvasTexture(barkCanvas);
            barkTexture.wrapS = barkTexture.wrapT = THREE.RepeatWrapping;
            barkTexture.repeat.set(3, 8);
            
            // Create trunk segments with more character
            for (let i = 0; i < segments; i++) {
                const t = i / segments;
                const baseRadius = 1.8;
                const taper = 1 - Math.pow(t, 1.5) * 0.7;
                const bulge = Math.sin(t * Math.PI * 5) * 0.8 * (0.4 + Math.random() * 0.6);
                const radius = Math.max(0.6, baseRadius * taper + bulge * 0.4);
                
                // More organic twist and bend
                const twist = t * Math.PI * 5;
                const bendX = Math.cos(t * Math.PI * 3) * (0.8 + Math.random() * 0.4);
                const bendZ = Math.sin(t * Math.PI * 2.5) * (0.6 + Math.random() * 0.3);
                
                const height = trunkHeight / segments;
                const geo = new THREE.CylinderGeometry(radius, radius * 0.95, height, 16, 4);
                
                const mat = new THREE.MeshStandardMaterial({
                    color: i < segments * 0.3 ? CONFIG.COLORS.WOOD_DARK : 
                           i < segments * 0.7 ? CONFIG.COLORS.WOOD : CONFIG.COLORS.WOOD_LIGHT,
                    roughness: 0.9,
                    metalness: 0.05,
                    map: barkTexture,
                    bumpMap: barkTexture,
                    bumpScale: 0.05
                });
                
                const segment = new THREE.Mesh(geo, mat);
                segment.position.y = i * height + height / 2 - 0.5;
                segment.position.x = bendX * t * 1.5;
                segment.position.z = bendZ * t * 1.5;
                segment.rotation.y = twist;
                segment.rotation.x = Math.sin(i * 0.3) * 0.15;
                segment.castShadow = true;
                segment.receiveShadow = true;
                
                segment.userData = {
                    baseY: segment.position.y,
                    baseX: segment.position.x,
                    baseZ: segment.position.z,
                    baseRotY: segment.rotation.y,
                    offset: i * 0.5,
                    breatheAmp: 0.02 + Math.random() * 0.03,
                    breatheSpeed: 0.4 + Math.random() * 0.4
                };
                
                scene.add(segment);
                tree.trunk.push(segment);
                
                // Create moss platforms/ledges
                if (i > 4 && i % 6 === 0 && i < segments - 5) {
                    createMossPlatform(segment.position, radius);
                }
                
                // Add gnarls and knots
                if (Math.random() > 0.7 && i > 3) {
                    createTreeGnarl(segment.position, radius);
                }
            }
            
            // Roots
            createRootSystem();
        }

        function createMossPlatform(position, radius) {
            const platSize = radius * (1.5 + Math.random() * 1.0);
            const platGeo = new THREE.SphereGeometry(platSize, 10, 6);
            const platMat = new THREE.MeshStandardMaterial({
                color: CONFIG.COLORS.MOSS,
                roughness: 0.9,
                emissive: CONFIG.COLORS.MOSS,
                emissiveIntensity: 0.1
            });
            
            const platform = new THREE.Mesh(platGeo, platMat);
            platform.scale.y = 0.15 + Math.random() * 0.1;
            platform.position.copy(position);
            platform.position.x += (Math.random() - 0.5) * radius * 0.8;
            platform.position.z += (Math.random() - 0.5) * radius * 0.8;
            platform.rotation.y = Math.random() * Math.PI * 2;
            platform.castShadow = true;
            platform.receiveShadow = true;
            
            scene.add(platform);
            tree.platforms.push(platform);
            
            return platform;
        }

        function createTreeGnarl(position, radius) {
            const gnarlSize = radius * (0.4 + Math.random() * 0.4);
            const gnarlGeo = new THREE.IcosahedronGeometry(gnarlSize, 1);
            const gnarlMat = new THREE.MeshStandardMaterial({
                color: CONFIG.COLORS.WOOD_DARK,
                roughness: 0.95
            });
            
            const gnarl = new THREE.Mesh(gnarlGeo, gnarlMat);
            gnarl.position.copy(position);
            gnarl.position.x += radius * 0.8 * Math.cos(Math.random() * Math.PI * 2);
            gnarl.position.z += radius * 0.8 * Math.sin(Math.random() * Math.PI * 2);
            gnarl.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            
            scene.add(gnarl);
            tree.trunk.push(gnarl);
        }

        function createRootSystem() {
            const rootCount = 8;
            for (let r = 0; r < rootCount; r++) {
                const angle = (r / rootCount) * Math.PI * 2;
                const length = 2 + Math.random() * 3;
                const segments = 8;
                
                const curve = new THREE.CatmullRomCurve3([
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(
                        Math.cos(angle) * length * 0.3,
                        -1,
                        Math.sin(angle) * length * 0.3
                    ),
                    new THREE.Vector3(
                        Math.cos(angle) * length,
                        -2 - Math.random(),
                        Math.sin(angle) * length
                    )
                ]);
                
                const rootGeo = new THREE.TubeGeometry(curve, segments, 0.4 + Math.random() * 0.3, 8, false);
                const rootMat = new THREE.MeshStandardMaterial({
                    color: CONFIG.COLORS.WOOD_DARK,
                    roughness: 0.95
                });
                
                const root = new THREE.Mesh(rootGeo, rootMat);
                root.castShadow = true;
                scene.add(root);
                tree.trunk.push(root);
            }
        }

        function createBranchNetwork() {
            const mainBranches = 12;
            const secondaryBranches = 24;
            
            // Primary branches
            for (let i = 0; i < mainBranches; i++) {
                const angle = (i / mainBranches) * Math.PI * 2;
                const startHeight = 6 + Math.random() * 4;
                const length = 4 + Math.random() * 3;
                createOrganicBranch(angle, startHeight, 0, length, 0.4, true);
            }
            
            // Secondary branches
            for (let i = 0; i < secondaryBranches; i++) {
                const angle = Math.random() * Math.PI * 2;
                const startHeight = 8 + Math.random() * 5;
                const length = 2 + Math.random() * 2;
                createOrganicBranch(angle, startHeight, 0, length, 0.25, false);
            }
        }

        function createOrganicBranch(angle, startY, generation, length, thickness, isPrimary) {
            if (generation > 3 || length < 0.8) return;
            
            const segments = 12;
            const points = [];
            const curvature = isPrimary ? 0.6 + Math.random() * 0.8 : 0.3 + Math.random() * 0.5;
            
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const radius = t * length * (1 + Math.sin(t * Math.PI) * 0.3);
                const lift = Math.pow(t, 0.8) * (isPrimary ? 3 : 1.5);
                const naturalBend = Math.sin(t * Math.PI) * curvature;
                const wiggle = Math.sin(t * Math.PI * 8 + generation * 2) * 0.15;
                
                points.push(new THREE.Vector3(
                    Math.cos(angle) * radius + naturalBend,
                    startY + lift,
                    Math.sin(angle) * radius + wiggle
                ));
            }
            
            const curve = new THREE.CatmullRomCurve3(points);
            const geo = new THREE.TubeGeometry(curve, segments, thickness, 8, false);
            const mat = new THREE.MeshStandardMaterial({
                color: generation === 0 ? CONFIG.COLORS.WOOD : CONFIG.COLORS.WOOD_LIGHT,
                roughness: 0.9,
                metalness: 0.05
            });
            
            const branch = new THREE.Mesh(geo, mat);
            branch.castShadow = true;
            branch.userData = {
                curve: curve,
                generation: generation,
                offset: Math.random() * Math.PI * 2,
                breatheSpeed: 0.3 + Math.random() * 0.4,
                breatheAmp: 0.02 + Math.random() * 0.03,
                isPrimary: isPrimary
            };
            
            scene.add(branch);
            tree.branches.push(branch);
            
            // Create sub-branches
            if (generation < 2) {
                const subCount = isPrimary ? 3 : 2;
                for (let s = 0; s < subCount; s++) {
                    const splitT = 0.4 + Math.random() * 0.4;
                    const splitPoint = curve.getPointAt(splitT);
                    const newAngle = angle + (Math.random() - 0.5) * (isPrimary ? 1.5 : 0.8);
                    const newLength = length * (0.5 + Math.random() * 0.3);
                    createOrganicBranch(newAngle, splitPoint.y, generation + 1, newLength, thickness * 0.7, false);
                }
            }
        }

        function createBreathingCanopy() {
            // Create instanced leaves for performance
            const leafGeo = new THREE.SphereGeometry(1, 7, 7);
            const leafMat = new THREE.MeshStandardMaterial({
                color: CONFIG.COLORS.LEAF_MED,
                roughness: 0.9,
                metalness: 0.05,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.85,
                emissive: CONFIG.COLORS.LEAF_MED,
                emissiveIntensity: 0.1
            });
            
            leafInstances = new THREE.InstancedMesh(leafGeo, leafMat, CONFIG.PERFORMANCE.LEAF_COUNT);
            leafInstances.castShadow = true;
            
            // Initialize instance data
            leafInstances.userData.instances = [];
            
            for (let i = 0; i < CONFIG.PERFORMANCE.LEAF_COUNT; i++) {
                const layer = Math.floor(Math.random() * 4); // 4 layers of leaves
                const layerT = layer / 3;
                const baseY = 10 + layer * 2.5 + Math.random() * 1.5;
                const maxRadius = 12 * (1 - layerT * 0.6);
                const angle = Math.random() * Math.PI * 2;
                const radius = maxRadius * (0.3 + Math.random() * 0.7);
                
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const y = baseY + (Math.random() - 0.5) * 1.5;
                
                // Random leaf color variation
                const colorChoice = Math.random();
                let leafColor;
                if (colorChoice < 0.3) leafColor = CONFIG.COLORS.LEAF_LIGHT;
                else if (colorChoice < 0.6) leafColor = CONFIG.COLORS.LEAF_MED;
                else if (colorChoice < 0.85) leafColor = CONFIG.COLORS.LEAF_DARK;
                else leafColor = CONFIG.COLORS.MOSS;
                
                // Random scale and rotation
                const scaleX = 0.8 + Math.random() * 0.6;
                const scaleY = 1.0 + Math.random() * 0.8;
                const scaleZ = 0.8 + Math.random() * 0.6;
                
                leafDummy.position.set(x, y, z);
                leafDummy.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                leafDummy.scale.set(scaleX, scaleY, scaleZ);
                leafDummy.updateMatrix();
                leafInstances.setMatrixAt(i, leafDummy.matrix);
                
                // Store per-instance data
                leafInstances.userData.instances[i] = {
                    baseX: x,
                    baseY: y,
                    baseZ: z,
                    baseScaleX: scaleX,
                    baseScaleY: scaleY,
                    baseScaleZ: scaleZ,
                    color: leafColor,
                    offset: Math.random() * Math.PI * 2,
                    breatheSpeed: 0.5 + Math.random() * 0.8,
                    breatheAmp: 0.2 + Math.random() * 0.3,
                    pulseSpeed: 0.7 + Math.random() * 1.0,
                    pulseAmp: 0.1 + Math.random() * 0.15
                };
            }
            
            leafInstances.instanceMatrix.needsUpdate = true;
            scene.add(leafInstances);
            tree.leafInstances = leafInstances;
        }

        // ===================== MAGICAL EFFECTS =====================
        function createMagicalEffects() {
            createKodamas();
            createSpiritOrbs();
            createFireflies();
            createFloatingParticles();
        }

        function createKodamas() {
            for (let i = 0; i < CONFIG.PERFORMANCE.KODAMAS; i++) {
                const kodama = new THREE.Group();
                
                // Body (head)
                const bodyGeo = new THREE.SphereGeometry(0.2, 12, 12);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: 0xE8F8F0,
                    emissive: CONFIG.COLORS.SPIRIT_LIGHT,
                    emissiveIntensity: 0.4,
                    roughness: 0.8,
                    transparent: true,
                    opacity: 0.9
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 0.4;
                kodama.add(body);
                
                // Eyes
                const eyeGeo = new THREE.SphereGeometry(0.05, 8, 8);
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0x0A1A1A });
                
                const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                const rightEye = leftEye.clone();
                leftEye.position.set(-0.08, 0.48, 0.15);
                rightEye.position.set(0.08, 0.48, 0.15);
                kodama.add(leftEye);
                kodama.add(rightEye);
                
                // Place on platforms or branches
                let position;
                if (tree.platforms.length > 0 && Math.random() > 0.3) {
                    const plat = tree.platforms[Math.floor(Math.random() * tree.platforms.length)];
                    position = plat.position.clone();
                    position.y += plat.scale.y * 0.8 + 0.1;
                } else {
                    // Place on ground near tree
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 3 + Math.random() * 5;
                    position = new THREE.Vector3(
                        Math.cos(angle) * radius,
                        0.3,
                        Math.sin(angle) * radius
                    );
                }
                
                kodama.position.copy(position);
                kodama.scale.setScalar(0.8 + Math.random() * 0.6);
                
                kodama.userData = {
                    baseY: kodama.position.y,
                    bobAmp: 0.08 + Math.random() * 0.1,
                    bobSpeed: 0.5 + Math.random() * 0.5,
                    offset: Math.random() * Math.PI * 2,
                    headBob: 0,
                    attention: 0,
                    targetAttention: 0,
                    isLookingAtCamera: false
                };
                
                scene.add(kodama);
                tree.kodamas.push(kodama);
            }
        }

        function createSpiritOrbs() {
            for (let i = 0; i < CONFIG.PERFORMANCE.SPIRITS; i++) {
                const geo = new THREE.SphereGeometry(0.15, 12, 12);
                const mat = new THREE.MeshBasicMaterial({
                    color: CONFIG.COLORS.KODAMA_GLOW,
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending
                });
                
                const spirit = new THREE.Mesh(geo, mat);
                
                const angle = Math.random() * Math.PI * 2;
                const radius = 5 + Math.random() * 15;
                const height = 4 + Math.random() * 14;
                
                spirit.position.set(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );
                
                spirit.userData = {
                    basePos: spirit.position.clone(),
                    angle: angle,
                    radius: radius,
                    baseY: height,
                    bobSpeed: 0.3 + Math.random() * 0.5,
                    bobHeight: 0.5 + Math.random() * 0.8,
                    rotateSpeed: 0.02 + Math.random() * 0.04,
                    pulseSpeed: 0.6 + Math.random() * 1.0,
                    offset: Math.random() * Math.PI * 2,
                    brightness: 0.3
                };
                
                scene.add(spirit);
                tree.spirits.push(spirit);
            }
        }

        function createFireflies() {
            for (let i = 0; i < CONFIG.PERFORMANCE.FIREFLIES; i++) {
                const geo = new THREE.SphereGeometry(0.06, 8, 8);
                const mat = new THREE.MeshBasicMaterial({
                    color: 0xA0C0FF,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                
                const firefly = new THREE.Mesh(geo, mat);
                
                const angle = Math.random() * Math.PI * 2;
                const radius = 3 + Math.random() * 12;
                const height = 2 + Math.random() * 16;
                
                firefly.position.set(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );
                
                firefly.userData = {
                    angle: angle,
                    radius: radius,
                    baseY: height,
                    speed: 0.03 + Math.random() * 0.1,
                    verticalSpeed: 0.1 + Math.random() * 0.2,
                    pulseSpeed: 1.0 + Math.random() * 1.5,
                    offset: Math.random() * Math.PI * 2,
                    verticalOffset: Math.random() * Math.PI * 2,
                    isActive: true
                };
                
                scene.add(firefly);
                tree.fireflies.push(firefly);
            }
        }

        function createFloatingParticles() {
            const particleGeo = new THREE.SphereGeometry(0.02, 6, 6);
            const particleMat = new THREE.MeshBasicMaterial({
                color: CONFIG.COLORS.SPIRIT_LIGHT,
                transparent: true,
                opacity: 0.1,
                blending: THREE.AdditiveBlending
            });
            
            for (let i = 0; i < CONFIG.PERFORMANCE.PARTICLES; i++) {
                const particle = new THREE.Mesh(particleGeo, particleMat);
                
                particle.position.set(
                    (Math.random() - 0.5) * 30,
                    2 + Math.random() * 18,
                    (Math.random() - 0.5) * 30
                );
                
                particle.userData = {
                    basePos: particle.position.clone(),
                    driftX: (Math.random() - 0.5) * 0.01,
                    driftZ: (Math.random() - 0.5) * 0.01,
                    bobSpeed: 0.1 + Math.random() * 0.3,
                    bobAmp: 0.2 + Math.random() * 0.4,
                    offset: Math.random() * Math.PI * 2
                };
                
                scene.add(particle);
                tree.particles.push(particle);
            }
        }

        function createShrine() {
            // Small Shinto-style shrine at base
            const shrineGroup = new THREE.Group();
            
            // Torii gate
            const toriiRed = 0xB22222;
            const toriiGeo1 = new THREE.BoxGeometry(0.3, 3, 0.3);
            const toriiMat1 = new THREE.MeshStandardMaterial({ color: toriiRed, roughness: 0.7 });
            
            const leftPillar = new THREE.Mesh(toriiGeo1, toriiMat1);
            leftPillar.position.set(-1.5, 1.5, -3);
            shrineGroup.add(leftPillar);
            
            const rightPillar = leftPillar.clone();
            rightPillar.position.set(1.5, 1.5, -3);
            shrineGroup.add(rightPillar);
            
            // Torii crossbeam
            const beamGeo = new THREE.BoxGeometry(3.5, 0.2, 0.4);
            const beam = new THREE.Mesh(beamGeo, toriiMat1);
            beam.position.set(0, 2.8, -3);
            shrineGroup.add(beam);
            
            // Offering stone
            const stoneGeo = new THREE.CylinderGeometry(0.6, 0.8, 0.3, 8);
            const stoneMat = new THREE.MeshStandardMaterial({ 
                color: CONFIG.COLORS.STONE, 
                roughness: 0.9 
            });
            const offeringStone = new THREE.Mesh(stoneGeo, stoneMat);
            offeringStone.position.set(0, 0.15, -2);
            offeringStone.rotation.y = Math.random() * Math.PI;
            shrineGroup.add(offeringStone);
            
            // Offerings (fruit, cloth)
            const offeringGeo = new THREE.SphereGeometry(0.2, 8, 8);
            const offeringMat = new THREE.MeshStandardMaterial({ color: 0xFF6B6B, roughness: 0.5 });
            const fruit = new THREE.Mesh(offeringGeo, offeringMat);
            fruit.position.set(0.2, 0.45, -2);
            shrineGroup.add(fruit);
            
            // Place shrine
            shrineGroup.position.y = -0.3;
            shrineGroup.rotation.y = Math.PI * 0.25;
            scene.add(shrineGroup);
            tree.shrine = shrineGroup;
        }

        // ===================== MEDIAPIPE INTEGRATION =====================
        async function initMediaPipe() {
            updateLoadingText("Initializing camera magic...");
            
            videoElement = document.getElementById('video');
            canvasElement = document.getElementById('output-canvas');
            canvasCtx = canvasElement.getContext('2d');
            
            // Initialize camera
            cameraInstance = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                    await faceMesh.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            
            // Initialize Hands
            hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});
            
            hands.setOptions(CONFIG.MEDIAPIPE.HANDS);
            
            hands.onResults((results) => {
                handleHandResults(results);
            });
            
            // Initialize Face Mesh
            faceMesh = new FaceMesh({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
            }});
            
            faceMesh.setOptions(CONFIG.MEDIAPIPE.FACE);
            
            faceMesh.onResults((results) => {
                handleFaceResults(results);
            });
            
            // Start camera
            try {
                await cameraInstance.start();
                updateStatus('webcam', true, 'Active');
                
                // Start MediaPipe
                await hands.initialize();
                await faceMesh.initialize();
                updateStatus('mediapipe', true, 'Active');
                
                // Start drawing
                canvasElement.width = videoElement.videoWidth;
                canvasElement.height = videoElement.videoHeight;
                
            } catch (error) {
                console.error('MediaPipe initialization failed:', error);
                updateStatus('webcam', false, 'Failed');
                updateStatus('mediapipe', false, 'Failed');
                
                // Fallback: Create simulated interactions
                createSimulatedInteractions();
            }
        }

        function handleHandResults(results) {
            lastHandDetection = Date.now();
            
            // Clear canvas
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                // Draw hand landmarks
                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, 
                        {color: '#00FF00', lineWidth: 2});
                    drawLandmarks(canvasCtx, landmarks, 
                        {color: '#FF0000', lineWidth: 1});
                }
                
                // Analyze gestures for each hand
                results.multiHandLandmarks.forEach((landmarks, handIndex) => {
                    const gesture = detectGesture(landmarks);
                    handleGesture(gesture, handIndex);
                });
            }
            
            canvasCtx.restore();
        }

        function handleFaceResults(results) {
            lastFaceDetection = Date.now();
            
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                
                // Detect facial expressions
                const leftEyeOpen = isEyeOpen(landmarks, true);
                const rightEyeOpen = isEyeOpen(landmarks, false);
                const mouthOpen = isMouthOpen(landmarks);
                
                // Handle facial interactions
                if (!leftEyeOpen && !rightEyeOpen) {
                    // Blinking
                    triggerInteraction('blink');
                }
                
                if (mouthOpen) {
                    triggerInteraction('mouth_open');
                }
                
                // Draw face mesh (optional, can be disabled for performance)
                drawConnectors(canvasCtx, landmarks, FACEMESH_TESSELATION, 
                    {color: '#C0C0C070', lineWidth: 1});
            }
        }

        function detectGesture(landmarks) {
            // Simple gesture detection based on finger positions
            const tips = {
                thumb: landmarks[4],
                index: landmarks[8],
                middle: landmarks[12],
                ring: landmarks[16],
                pinky: landmarks[20],
                wrist: landmarks[0]
            };
            
            // Calculate distances
            const indexToThumb = distance(tips.index, tips.thumb);
            const middleToWrist = distance(tips.middle, tips.wrist);
            const pinkyToWrist = distance(tips.pinky, tips.wrist);
            
            // Open hand (all fingers extended)
            const allExtended = 
                distance(tips.index, tips.wrist) > 0.3 &&
                distance(tips.middle, tips.wrist) > 0.3 &&
                distance(tips.ring, tips.wrist) > 0.3 &&
                distance(tips.pinky, tips.wrist) > 0.3;
            
            // Peace sign (index and middle extended, others closed)
            const peaceSign = 
                distance(tips.index, tips.wrist) > 0.3 &&
                distance(tips.middle, tips.wrist) > 0.3 &&
                distance(tips.ring, tips.wrist) < 0.2 &&
                distance(tips.pinky, tips.wrist) < 0.2 &&
                indexToThumb > 0.2;
            
            // Fist (all fingers closed)
            const fist = 
                distance(tips.index, tips.wrist) < 0.15 &&
                distance(tips.middle, tips.wrist) < 0.15 &&
                distance(tips.ring, tips.wrist) < 0.15 &&
                distance(tips.pinky, tips.wrist) < 0.15;
            
            if (allExtended && indexToThumb > 0.3) {
                return 'open_hand';
            } else if (peaceSign) {
                return 'peace_sign';
            } else if (fist) {
                return 'fist';
            }
            
            return 'unknown';
        }

        function handleGesture(gesture, handIndex) {
            switch(gesture) {
                case 'open_hand':
                    triggerInteraction('open_hand');
                    break;
                case 'peace_sign':
                    triggerInteraction('peace_sign');
                    break;
                case 'fist':
                    triggerInteraction('fist');
                    break;
            }
        }

        function triggerInteraction(type) {
            clearTimeout(interactionTimeout);
            currentInteraction = type;
            updateInteractionDisplay(type);
            
            // Update tree based on interaction
            switch(type) {
                case 'open_hand':
                    // Brighten spirits
                    tree.spirits.forEach(spirit => {
                        spirit.userData.brightness = Math.min(1.0, spirit.userData.brightness + 0.1);
                    });
                    tree.spiritGlow.intensity = 3.0;
                    playSound('spirit-sound');
                    break;
                    
                case 'peace_sign':
                    // Create more fireflies
                    for (let i = 0; i < 10; i++) {
                        createAdditionalFirefly();
                    }
                    playSound('spirit-sound');
                    break;
                    
                case 'blink':
                    // Kodamas look at camera
                    tree.kodamas.forEach(kodama => {
                        kodama.userData.targetAttention = 1.0;
                    });
                    break;
                    
                case 'mouth_open':
                    // Gentle breeze
                    CONFIG.ANIMATION.WIND_STRENGTH = 1.0;
                    playSound('wind-sound');
                    break;
                    
                case 'fist':
                    // Calm everything
                    tree.spirits.forEach(spirit => {
                        spirit.userData.brightness = 0.3;
                    });
                    CONFIG.ANIMATION.WIND_STRENGTH = 0.2;
                    break;
            }
            
            // Reset after 3 seconds
            interactionTimeout = setTimeout(() => {
                currentInteraction = 'none';
                updateInteractionDisplay('No active interaction');
                CONFIG.ANIMATION.WIND_STRENGTH = 0.5;
            }, 3000);
        }

        // ===================== ANIMATION LOOP =====================
        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;
            
            // Update day/night cycle
            updateDayNightCycle();
            
            // Animate tree trunk
            animateTrunk();
            
            // Animate branches
            animateBranches();
            
            // Animate leaves (instanced)
            animateLeaves();
            
            // Animate grass
            animateGrass();
            
            // Animate magical effects
            animateSpirits();
            animateKodamas();
            animateFireflies();
            animateParticles();
            
            // Update camera
            updateCamera();
            
            // Update lights
            updateLights();
            
            // Render with post-processing
            composer.render();
        }

        function animateTrunk() {
            tree.trunk.forEach((segment, i) => {
                if (segment.userData && segment.userData.breatheSpeed) {
                    const breath = Math.sin(time * segment.userData.breatheSpeed + segment.userData.offset);
                    const breathAmount = breath * segment.userData.breatheAmp * animationStrength;
                    
                    segment.rotation.z = segment.userData.baseRotZ + breathAmount;
                    segment.position.y = segment.userData.baseY + breathAmount * 0.5;
                    
                    const scale = 1 + breathAmount * 0.5;
                    segment.scale.set(scale, 1 + breathAmount * 0.2, scale);
                }
            });
        }

        function animateBranches() {
            tree.branches.forEach(branch => {
                if (branch.userData) {
                    const sway = Math.sin(time * branch.userData.breatheSpeed + branch.userData.offset);
                    const swayAmount = sway * branch.userData.breatheAmp * animationStrength;
                    
                    branch.rotation.x = swayAmount;
                    branch.rotation.z = Math.cos(time * branch.userData.breatheSpeed * 0.7) * swayAmount * 0.6;
                    
                    // Wind effect
                    const windSway = Math.sin(time * 0.8) * CONFIG.ANIMATION.WIND_STRENGTH * 0.1;
                    branch.rotation.y += windSway * 0.01;
                }
            });
        }

        function animateLeaves() {
            if (!leafInstances || !leafInstances.userData.instances) return;
            
            const matrices = leafInstances.instanceMatrix.array;
            const count = leafInstances.count;
            
            for (let i = 0; i < count; i++) {
                const data = leafInstances.userData.instances[i];
                if (!data) continue;
                
                // Calculate breathing and pulsing
                const breath = Math.sin(time * data.breatheSpeed + data.offset);
                const pulse = 1 + Math.sin(time * data.pulseSpeed + data.offset * 2) * data.pulseAmp;
                const wind = Math.sin(time * 1.2 + i * 0.01) * CONFIG.ANIMATION.WIND_STRENGTH * 0.3;
                
                // Calculate new position with wind
                const newX = data.baseX + breath * data.breatheAmp * 0.5 + wind;
                const newY = data.baseY + Math.cos(time * data.breatheSpeed * 0.8 + data.offset) * data.breatheAmp * 0.3;
                const newZ = data.baseZ + Math.sin(time * data.breatheSpeed * 0.6 + data.offset + 1) * data.breatheAmp * 0.5;
                
                // Update instance matrix
                leafDummy.position.set(newX, newY, newZ);
                leafDummy.scale.set(
                    data.baseScaleX * pulse,
                    data.baseScaleY * pulse,
                    data.baseScaleZ * pulse
                );
                
                // Slight rotation
                leafDummy.rotation.y = time * 0.1 + data.offset;
                leafDummy.rotation.x = breath * 0.2;
                
                leafDummy.updateMatrix();
                leafInstances.setMatrixAt(i, leafDummy.matrix);
            }
            
            leafInstances.instanceMatrix.needsUpdate = true;
        }

        function animateGrass() {
            if (!grassInstances || !grassInstances.userData.instances) return;
            
            const matrices = grassInstances.instanceMatrix.array;
            const count = grassInstances.count;
            
            for (let i = 0; i < count; i++) {
                const data = grassInstances.userData.instances[i];
                if (!data) continue;
                
                const sway = Math.sin(time * data.speed + data.offset);
                const windSway = Math.sin(time * 1.5 + data.baseX * 0.1) * CONFIG.ANIMATION.WIND_STRENGTH * 0.5;
                
                grassDummy.position.set(data.baseX, 0, data.baseZ);
                grassDummy.rotation.z = sway * data.amp + windSway * 0.1;
                grassDummy.rotation.x = Math.cos(time * data.speed * 0.7 + data.offset) * data.amp * 0.3;
                grassDummy.updateMatrix();
                grassInstances.setMatrixAt(i, grassDummy.matrix);
            }
            
            grassInstances.instanceMatrix.needsUpdate = true;
        }

        function animateSpirits() {
            tree.spirits.forEach(spirit => {
                const data = spirit.userData;
                if (!data) return;
                
                // Orbital motion
                data.angle += data.rotateSpeed;
                spirit.position.x = Math.cos(data.angle) * data.radius;
                spirit.position.z = Math.sin(data.angle) * data.radius;
                
                // Bobbing
                spirit.position.y = data.baseY + Math.sin(time * data.bobSpeed + data.offset) * data.bobHeight;
                
                // Pulsing glow
                const pulse = 0.3 + Math.sin(time * data.pulseSpeed + data.offset) * 0.3;
                const brightness = data.brightness || 0.3;
                spirit.material.opacity = brightness * (0.3 + pulse * 0.5);
                spirit.scale.setScalar(0.8 + pulse * 0.4);
                
                // Gradually return to normal brightness
                if (data.brightness > 0.3) {
                    data.brightness -= 0.005;
                }
            });
        }

        function animateKodamas() {
            tree.kodamas.forEach(kodama => {
                const data = kodama.userData;
                if (!data) return;
                
                // Bobbing
                kodama.position.y = data.baseY + Math.sin(time * data.bobSpeed + data.offset) * data.bobAmp;
                
                // Head bobbing
                data.headBob += 0.03;
                kodama.children[0].rotation.x = Math.sin(data.headBob) * 0.08;
                
                // Attention to camera
                if (data.targetAttention > data.attention) {
                    data.attention += 0.02;
                } else if (data.targetAttention < data.attention) {
                    data.attention -= 0.02;
                }
                
                // Look at camera when attention is high
                if (data.attention > 0.5) {
                    kodama.lookAt(camera.position);
                    // Keep kodama upright
                    kodama.rotation.x = 0;
                    kodama.rotation.z = 0;
                } else {
                    kodama.rotation.y = Math.sin(time * 0.3 + data.offset) * 0.2;
                }
                
                // Glow with attention
                const glow = 0.3 + data.attention * 0.2;
                kodama.children[0].material.emissiveIntensity = glow;
            });
        }

        function animateFireflies() {
            tree.fireflies.forEach(firefly => {
                const data = firefly.userData;
                if (!data || !data.isActive) return;
                
                // Orbital motion
                data.angle += data.speed;
                firefly.position.x = Math.cos(data.angle) * data.radius;
                firefly.position.z = Math.sin(data.angle) * data.radius;
                
                // Vertical movement
                firefly.position.y = data.baseY + Math.sin(time * data.verticalSpeed + data.verticalOffset) * 2;
                
                // Pulsing
                const pulse = Math.sin(time * data.pulseSpeed + data.offset) * 0.5 + 0.5;
                firefly.material.opacity = 0.4 + pulse * 0.4;
                firefly.scale.setScalar(0.5 + pulse * 0.3);
            });
        }

        function animateParticles() {
            tree.particles.forEach(particle => {
                const data = particle.userData;
                if (!data) return;
                
                // Drift
                particle.position.x += data.driftX;
                particle.position.z += data.driftZ;
                particle.position.y = data.basePos.y + Math.sin(time * data.bobSpeed + data.offset) * data.bobAmp;
                
                // Wrap around
                if (particle.position.x > 25) particle.position.x = -25;
                if (particle.position.x < -25) particle.position.x = 25;
                if (particle.position.z > 25) particle.position.z = -25;
                if (particle.position.z < -25) particle.position.z = 25;
            });
        }

        function updateCamera() {
            // Slow orbital camera movement
            const camAngle = time * 0.015;
            const radius = 38 + Math.sin(time * 0.05) * 3;
            const height = 16 + Math.sin(time * 0.03) * 2;
            
            camera.position.x = Math.cos(camAngle) * radius;
            camera.position.z = Math.sin(camAngle) * radius;
            camera.position.y = height;
            
            // Look at tree with slight offset
            const lookOffset = Math.sin(time * 0.02) * 3;
            camera.lookAt(0, 12 + lookOffset, 0);
            
            // Update camera controls based on interaction
            if (currentInteraction === 'open_hand') {
                camera.position.y += Math.sin(time * 2) * 0.5;
            }
        }

        function updateLights() {
            // Day/night lighting
            const dayIntensity = isDay ? 1.0 : 0.0;
            const nightIntensity = isDay ? 0.0 : 1.0;
            
            // Smooth transitions
            tree.sunLight.intensity = dayIntensity * 0.8;
            tree.moonLight.intensity = nightIntensity * 0.7;
            
            // Ambient light adjustment
            scene.fog.color.lerpColors(
                new THREE.Color(CONFIG.COLORS.NIGHT_SKY),
                new THREE.Color(CONFIG.COLORS.DAY_SKY),
                dayNightProgress
            );
            
            // Spirit glow
            if (tree.spiritGlow) {
                const pulse = 2.0 + Math.sin(time * 0.6) * 1.0;
                tree.spiritGlow.intensity = pulse;
                tree.spiritGlow.position.y = 20 + Math.sin(time * 0.3) * 1.5;
            }
        }

        function updateDayNightCycle() {
            // Update progress
            dayNightProgress = (Math.sin(time / CONFIG.ANIMATION.DAY_NIGHT_CYCLE) + 1) / 2;
            isDay = dayNightProgress > 0.5;
            
            // Update sky gradient
            if (tree.sky && tree.sky.material.uniforms) {
                const skyColor = isDay ? 0x87CEEB : CONFIG.COLORS.NIGHT_SKY;
                tree.sky.material.uniforms.topColor.value.lerp(
                    new THREE.Color(skyColor),
                    0.05
                );
            }
        }

        // ===================== UI & CONTROLS =====================
        function initUI() {
            // Day/Night toggle
            document.getElementById('day-night').addEventListener('click', () => {
                isDay = !isDay;
                dayNightProgress = isDay ? 1.0 : 0.0;
                updateDayNightCycle();
            });
            
            // Sound toggle
            document.getElementById('toggle-sound').addEventListener('click', () => {
                isSoundOn = !isSoundOn;
                const button = document.getElementById('toggle-sound');
                button.textContent = isSoundOn ? 'üîä Sound On' : 'üîá Sound Off';
                
                if (isSoundOn) {
                    document.getElementById('ambience').play().catch(e => console.log("Audio play failed:", e));
                } else {
                    document.getElementById('ambience').pause();
                }
            });
            
            // Reset tree
            document.getElementById('reset-tree').addEventListener('click', () => {
                animationStrength = 0.5;
                CONFIG.ANIMATION.WIND_STRENGTH = 0.5;
                document.getElementById('animation-slider').value = 50;
                document.getElementById('animation-value').textContent = '50%';
                updateInteractionDisplay('Tree reset to calm state');
            });
            
            // Brightness slider
            const brightnessSlider = document.getElementById('brightness-slider');
            const brightnessValue = document.getElementById('brightness-value');
            
            brightnessSlider.addEventListener('input', (e) => {
                const value = e.target.value;
                brightnessValue.textContent = value + '%';
                
                // Adjust bloom effect
                bloomPass.strength = value / 100 * 1.5;
            });
            
            // Animation slider
            const animationSlider = document.getElementById('animation-slider');
            const animationValue = document.getElementById('animation-value');
            
            animationSlider.addEventListener('input', (e) => {
                const value = e.target.value;
                animationValue.textContent = value + '%';
                animationStrength = value / 100;
            });
        }

        function initAudio() {
            // Try to play ambient sound (will require user interaction on most browsers)
            const ambience = document.getElementById('ambience');
            ambience.volume = 0.3;
            
            // Preload other sounds
            document.getElementById('spirit-sound').volume = 0.5;
            document.getElementById('wind-sound').volume = 0.4;
        }

        function playSound(soundId) {
            if (!isSoundOn) return;
            
            const sound = document.getElementById(soundId);
            if (sound) {
                sound.currentTime = 0;
                sound.play().catch(e => console.log("Sound play failed:", e));
            }
        }

        // ===================== UTILITY FUNCTIONS =====================
        function updateLoadingText(text) {
            const element = document.getElementById('loading-text');
            if (element) {
                element.textContent = text;
            }
        }

        function updateStatus(type, active, text) {
            const statusElement = document.getElementById(`${type}-status`);
            const textElement = document.getElementById(`${type}-text`);
            
            if (statusElement) {
                statusElement.className = `status-indicator ${active ? 'status-active' : 'status-inactive'}`;
            }
            
            if (textElement) {
                textElement.textContent = text;
            }
        }

        function updateInteractionDisplay(text) {
            const element = document.getElementById('current-interaction');
            if (element) {
                element.textContent = text;
            }
        }

        function createAdditionalFirefly() {
            if (tree.fireflies.length >= CONFIG.PERFORMANCE.FIREFLIES + 50) return;
            
            const geo = new THREE.SphereGeometry(0.06, 8, 8);
            const mat = new THREE.MeshBasicMaterial({
                color: 0xA0C0FF,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            
            const firefly = new THREE.Mesh(geo, mat);
            
            const angle = Math.random() * Math.PI * 2;
            const radius = 3 + Math.random() * 12;
            const height = 2 + Math.random() * 16;
            
            firefly.position.set(
                Math.cos(angle) * radius,
                height,
                Math.sin(angle) * radius
            );
            
            firefly.userData = {
                angle: angle,
                radius: radius,
                baseY: height,
                speed: 0.03 + Math.random() * 0.1,
                verticalSpeed: 0.1 + Math.random() * 0.2,
                pulseSpeed: 1.0 + Math.random() * 1.5,
                offset: Math.random() * Math.PI * 2,
                verticalOffset: Math.random() * Math.PI * 2,
                isActive: true,
                lifetime: 10 // Seconds before fading out
            };
            
            scene.add(firefly);
            tree.fireflies.push(firefly);
        }

        function createSimulatedInteractions() {
            // Fallback for when MediaPipe fails
            console.log("Creating simulated interactions...");
            
            // Simulate random interactions
            setInterval(() => {
                const interactions = ['open_hand', 'peace_sign', 'blink', 'mouth_open', 'fist'];
                const randomInteraction = interactions[Math.floor(Math.random() * interactions.length)];
                triggerInteraction(randomInteraction);
            }, 8000);
        }

        // Math utility functions
        function distance(point1, point2) {
            const dx = point1.x - point2.x;
            const dy = point1.y - point2.y;
            const dz = point1.z - point2.z;
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }

        function isEyeOpen(landmarks, isLeft) {
            // Simplified eye openness detection
            // Real implementation would use more landmarks
            return Math.random() > 0.1; // Simulated
        }

        function isMouthOpen(landmarks) {
            // Simplified mouth openness detection
            return Math.random() > 0.7; // Simulated
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function startAnimations() {
            animate();
            
            // Start ambient sound after user interaction
            document.addEventListener('click', () => {
                if (isSoundOn) {
                    document.getElementById('ambience').play().catch(e => console.log("Audio requires user interaction"));
                }
            }, { once: true });
        }

        // ===================== START EVERYTHING =====================
        window.addEventListener('load', init);
    </script>
</body>
</html>